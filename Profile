using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Import-Module PSReadLine
Set-PSReadLineOption -PredictionSource History
Set-PSReadLineOption -PredictionViewStyle ListView
#Set-PSReadLineOption -EditMode Windows

Set-PSReadLineKeyHandler -Key Tab -Function Complete

Set-PSReadLineKeyHandler -Chord '"', "'" `
    -BriefDescription SmartInsertQuote `
    -LongDescription "Insert paired quotes if not already on a quote" `
    -ScriptBlock {
    param($key, $arg)

    $line = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)

    if ($line.Length -gt $cursor -and $line[$cursor] -eq $key.KeyChar) {
        # Just move the cursor
        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)
    }
    else {
        # Insert matching quotes, move cursor to be in between the quotes
        [Microsoft.PowerShell.PSConsoleReadLine]::Insert("$($key.KeyChar)" * 2)
        [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)
        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor - 1)
    }
}



#
# Ctrl+Shift+j then type a key to mark the current directory.
# Ctrl+j then the same key will change back to that directory without
# needing to type cd and won't change the command line.

#
$global:PSReadLineMarks = @{}

Set-PSReadLineKeyHandler -Key Ctrl+J `
    -BriefDescription MarkDirectory `
    -LongDescription "Mark the current directory" `
    -ScriptBlock {
    param($key, $arg)

    $key = [Console]::ReadKey($true)
    $global:PSReadLineMarks[$key.KeyChar] = $pwd
}

Set-PSReadLineKeyHandler -Key Ctrl+j `
    -BriefDescription JumpDirectory `
    -LongDescription "Goto the marked directory" `
    -ScriptBlock {
    param($key, $arg)

    $key = [Console]::ReadKey()
    $dir = $global:PSReadLineMarks[$key.KeyChar]
    if ($dir) {
        cd $dir
        [Microsoft.PowerShell.PSConsoleReadLine]::InvokePrompt()
    }
}

Set-PSReadLineKeyHandler -Key Alt+j `
    -BriefDescription ShowDirectoryMarks `
    -LongDescription "Show the currently marked directories" `
    -ScriptBlock {
    param($key, $arg)

    $global:PSReadLineMarks.GetEnumerator() | % {
        [PSCustomObject]@{Key = $_.Key; Dir = $_.Value } } |
    Format-Table -AutoSize | Out-Host

    [Microsoft.PowerShell.PSConsoleReadLine]::InvokePrompt()
}

# Auto correct 'git cmt' to 'git commit'
Set-PSReadLineOption -CommandValidationHandler {
    param([CommandAst]$CommandAst)

    switch ($CommandAst.GetCommandName()) {
        'git' {
            $gitCmd = $CommandAst.CommandElements[1].Extent
            switch ($gitCmd.Text) {
                'cmt' {
                    [Microsoft.PowerShell.PSConsoleReadLine]::Replace(
                        $gitCmd.StartOffset, $gitCmd.EndOffset - $gitCmd.StartOffset, 'commit')
                }
            }
        }
    }
}


# This example will replace any aliases on the command line with the resolved commands.
Set-PSReadLineKeyHandler -Key "Alt+%" `
    -BriefDescription ExpandAliases `
    -LongDescription "Replace all aliases with the full command" `
    -ScriptBlock {
    param($key, $arg)

    $ast = $null
    $tokens = $null
    $errors = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$ast, [ref]$tokens, [ref]$errors, [ref]$cursor)

    $startAdjustment = 0
    foreach ($token in $tokens) {
        if ($token.TokenFlags -band [TokenFlags]::CommandName) {
            $alias = $ExecutionContext.InvokeCommand.GetCommand($token.Extent.Text, 'Alias')
            if ($alias -ne $null) {
                $resolvedCommand = $alias.ResolvedCommandName
                if ($resolvedCommand -ne $null) {
                    $extent = $token.Extent
                    $length = $extent.EndOffset - $extent.StartOffset
                    [Microsoft.PowerShell.PSConsoleReadLine]::Replace(
                        $extent.StartOffset + $startAdjustment,
                        $length,
                        $resolvedCommand)

                    # Our copy of the tokens won't have been updated, so we need to
                    # adjust by the difference in length
                    $startAdjustment += ($resolvedCommand.Length - $length)
                }
            }
        }
    }
}

# Sometimes you want to get a property of invoke a member on what you've entered so far
# but you need parens to do that.  This binding will help by putting parens around the current selection,
# or if nothing is selected, the whole line.
Set-PSReadLineKeyHandler -Key 'Alt+(' `
    -BriefDescription ParenthesizeSelection `
    -LongDescription "Put parenthesis around the selection or entire line and move the cursor to after the closing parenthesis" `
    -ScriptBlock {
    param($key, $arg)

    $selectionStart = $null
    $selectionLength = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetSelectionState([ref]$selectionStart, [ref]$selectionLength)

    $line = $null
    $cursor = $null
    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)
    if ($selectionStart -ne -1) {
        [Microsoft.PowerShell.PSConsoleReadLine]::Replace($selectionStart, $selectionLength, '(' + $line.SubString($selectionStart, $selectionLength) + ')')
        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($selectionStart + $selectionLength + 2)
    }
    else {
        [Microsoft.PowerShell.PSConsoleReadLine]::Replace(0, $line.Length, '(' + $line + ')')
        [Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()
    }
}

Function Set-Omp {
    Param (
        [Parameter(Position = 0, mandatory = $true)]
        [string]$Object,
        [Parameter(Position = 1)]
        [bool]$Value = $True,
        [switch]$Persistent = $False
    )
    if ($Persistent) {
        [Environment]::SetEnvironmentVariable("OMP_ADDE_$($Object)", "$Value", "User")
    }
    else {
        Set-Item "env:OMP_ADDE_$Object" $Value
    }
}

function Foo($bar) {
    Invoke-Expression gsudo
}

function Get-WifiPasswords($bar) {
     (netsh wlan show profiles) | Select-String '\:(.+)$' | % { $name = $_.Matches.Groups[1].Value.Trim(); $_ } | % { (netsh wlan show profile name=$name key=clear) } | Select-String 'Key Content\W+\:(.+)$' | % { $pass = $_.Matches.Groups[1].Value.Trim(); $_ } | % { [PSCustomObject]@{ PROFILE_NAME = $name; PASSWORD = $pass } } | Format-Table â€“AutoSize | Out-String -OutVariable dataCaptured
}

function Start-Winix($bar) {
    $IGNORE_CMD = @("ls", "cp", "diff", "tee", "sleep", "echo", "sort", "dir", "balle")

    echo "Adding commands from Git/bin"
    Get-ChildItem "C:\Program Files\Git\usr\bin" -Filter *.exe | Foreach-Object {
        $BASENAME = $($_.BaseName)
        echo "Processing: $BASENAME"
        if ( $IGNORE_CMD -contains $BASENAME ) {
            echo "Skipped $BASENAME"
			
        }
        else {
            echo "Adding: $($BASENAME) ->  $($_) " 
            Set-Alias -Name $($BASENAME) -Value "$($_)" -Scope Global
        }
    }
}



Import-Module PSColors
Import-Module -Name Terminal-Icons

Set-Alias -Name sudo -Value Foo

function Start-Winix2($bar) {
    Set-Alias -Name nano -Value 'C:\Program Files\Git\usr\bin\nano.exe'
    Set-Alias -Name cut -Value 'C:\Program Files\Git\usr\bin\cut.exe'
    Set-Alias -Name tr -Value 'C:\Program Files\Git\usr\bin\tr.exe'
    Set-Alias -Name printf -Value 'C:\Program Files\Git\usr\bin\printf.exe'
    Set-Alias -Name sed -Value 'C:\Program Files\Git\usr\bin\sed.exe'
    Set-Alias -Name tail -Value 'C:\Program Files\Git\usr\bin\tail.exe'
    Set-Alias -Name head -Value 'C:\Program Files\Git\usr\bin\head.exe'
    Set-Alias -Name grep -Value 'C:\Program Files\Git\usr\bin\grep.exe'
    Set-Alias -Name column -Value 'C:\Program Files\Git\usr\bin\column.exe'
    Set-Alias -Name realpath -Value 'C:\Program Files\Git\usr\bin\realpath.exe'
    Set-Alias -Name dirname -Value 'C:\Program Files\Git\usr\bin\dirname.exe'
    Set-Alias -Name basename -Value 'C:\Program Files\Git\usr\bin\basename.exe'
    Set-Alias -Name openssl -Value 'C:\Program Files\Git\usr\bin\openssl.exe'
    Set-Alias -Name ldd -Value 'C:\Program Files\Git\usr\bin\ldd.exe'
    Set-Alias -Name which -Value 'C:\Program Files\Git\usr\bin\which.exe'
    Set-Alias -Name ps -Value 'C:\Program Files\Git\usr\bin\ps.exe'
    Set-Alias -Name kill -Value 'C:\Program Files\Git\usr\bin\kill.exe'
    Set-Alias -Name mktemp -Value 'C:\Program Files\Git\usr\bin\mktemp.exe'
}
oh-my-posh init pwsh --config "$env:POSH_THEMES_PATH/adde.omp.json" | Invoke-Expression
